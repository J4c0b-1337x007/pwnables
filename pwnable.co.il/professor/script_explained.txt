Professor — Writeup (תקציר)
באתגר זה מנוצלת פונקציית gets() שנקראת מתוך ה-start routine. gets() אינה מבצעת בדיקת אורך הקלט ולכן אפשר לבצע buffer overflow ולדרוס את כתובת ה-RET. המתקפה מנצלת דופק-זיכרון (stack canary) על ידי דריסת ה-saved canary במחסנית וכן דריסת הערך הראשי ב-TLS canary, ולבסוף מריצת קוד של המשתמש (SHELL) בעזרת ROP וכתיבה ל-GOT של puts כך ש-puts יצביע על one_gadget.

---

גילוי ופירוט הפגיעות
- הפונקציה הפגיעת: gets() — קוראת קלט ללא הגבלת אורך → פתיחת אפשרות ל-stack buffer overflow.
- המערכת כוללת מנגנון stack canary (השוואה עם ערך TLS). כדי לאלץ עקיפה עלינו:
  1. להחליף את ה-saved canary במחסנית (saved canary).
  2. לשנות גם את הערך שאליו מתבצעת ההשוואה (ה-TLS canary / הערך הראשי), כך שההשוואה תעבור למרות הדריסה.
- לאחר דריסת הכתובת החוזרת (RET) נוכל לבצע return-oriented programming (ROP) — לשנות את ה-RET לכתובות gadget כדי להריץ רצף פקודות שבנויות בכתובות קיימות בזיכרון.

---

שיטה וטכניקה
1. איתור gadgets
   — gadget היא כתובת בזיכרון שמשלבת מספר פקודות POP/ MOV / ADD / RET שניתן "לשרשר" ביחד על-מנת להפעיל פעולות מורכבות בלי קוד חדש.
   — דוגמה של gadget שמוציא ערכים מ-registerים ואז מחזיר:
   pop_rbx_rbp_r12_r13_r14_r15 = p64(0x000000000040138a)
   ובכתובת זו נראה את רצף ההוראות (כדוגמה מתוך disassembly):
   0040138a 5b              POP        RBX
   0040138b 5d              POP        RBP
   0040138c 41 5c           POP        R12
   0040138e 41 5d           POP        R13
   00401390 41 5e           POP        R14
   00401392 41 5f           POP        R15
   00401394 c3              RET
   — שימוש ב-Ghidra/IDA מאפשר למצוא ולוודא את ה-gadgets האלו.

2. שבירת ההגנה (canary bypass)
   — כדי שהפונקציה תמשיך אחרי ret הדרוס, יש להסיר או לעקוף את מנגנון ה-canary: הדריסה חייבת לכלול גם שינוי בערך השמור וגם שינוי בערך המשמש להשוואה (TLS canary) או יצירת תנאי שבו ההשוואה עוברת.
   — לאחר שה-canary לא יעצור אותנו, ניתן לשרשר ROP chain.

3. שינוי GOT של puts → הפעלת one_gadget
   — רעיון מרכזי: לשנות את כתובת ה-GOT של puts כך שתצביע ל-one_gadget מתוך libc, ואז לקרוא ל-puts — מה שיפעיל את ה-one_gadget וייתן shell.
   — צריך לחשב את ההפרש בזיכרון בין ה-offset של puts ב-libc לבין ה-offset של ה-one_gadget:
   delta = offset_one_gadget - offset_puts
   — באמצעות gadget שמבצע כתיבה/חיבור בערך בזיכרון (לדוגמה gadget שמוסיף לערך בכתובת מסוימת), מוסיפים את ה-delta לערך הנמצא ב-GOT של puts.
   — לאחר ההוספה/שינוי נקרא ל-puts (דרך ROP) — זו בעצם קריאה לכתובת החדשה ששמנו ב-GOT (ה-one_gadget), מקבלת shell.

---

כלים ושורות פקודה שימושיות
- לניתוח בינארי: Ghidra, IDA Free (IDA לעיתים מדייקת יותר מ-Ghidra באסמבלר).
- למציאת one_gadget ב-libc:
  one_gadget ./libc.so.6
- למציאת offset של puts ב-libc:
  objdump -T ./libc.so.6 | grep ' puts$'
- להסתכל ב־PLT/דיסאסמבלי של הפונקציה puts בבינארי:
  objdump -d ./professor | grep "<puts@plt>"
- שימוש ב־ROP chaining: חפש gadgets עם ROPgadget/rp++/rp++ או ROPgadget --binary professor --only "pop|ret|mov|add|xor".

---

מבנה ה-ROP (תקציר)
1. gadget ראשון: מכין רישומים (pop values to registers) ומשמש כהכנה לכתיבה לזיכרון.
2. gadget שני: מבצע את פעולת הכתיבה/החיבור לכתובת GOT של puts.
3. קריאה ל-puts (דרך RET שעכשיו יעביר את הזרימה לכתובת ב-GOT) — שמובילה ל-one_gadget → SHELL.

---

דגשים חשובים / נקודות בעייתיות
- תמיד בדוק את ASLR / PIE / NX / RELRO של הבינארי וה-libc; התלות בכתובות סטטיות או חישוב offsets חייבת להתחשב בסטטוסים האלה.
- במערכת עם RELRO מלא או GOT-PLT מוגן, שיטה זו עלולה להיכשל — יש להתאים אסטרטגיה חלופית (למשל leak של כתובת libc ואז שימוש ב-ret2libc).
- הכתובות המדויקות של gadgets ו-offsetים תלויות בגרסת ה-libc והבינארי — ודא התאמה בין הגרסאות.

---

סיכום קצר (מה עשינו ולמה עובד)
- ניצלנו את חוסר ההגבלה של gets() כדי לגרום ל-buffer overflow.
- עקפנו את מנגנון ה-canary על-ידי דריסת הערכים הרלוונטיים (saved canary + TLS canary).
- בוצע ROP: השתמשנו ב-gadgets כדי לשנות את כניסת ה-GOT של puts כך שתצביע ל-one_gadget.
- קריאה ל-puts לאחר השינוי הריצה את ה-one_gadget ושחררה shell.

---

שלבים הבאים (הצעות)
- הוספת קטע קוד מסודר (pwn script ב-Python/pwntools) עם מבנה ה-ROP וה-offsets (אפשר לכלול דוגמת payload — לציין אם זה לפרסום פומבי).
- להוסיף README/MD מסודר במאגר ה-GitHub עם צילומי מסך של Ghidra/IDA ופקודות שהשתמשת בהן.
- להכין .gitignore ו-README קצר שמסביר דרישות להפעלת ה-exploit (גרסאות libc/הגדרות סביבה).

אם תרצה שאכלול דוגמת קוד exploit ב-Python/pwntools — תגיד אם זה לפרסום פומבי או רק ללימוד/PRIV.
